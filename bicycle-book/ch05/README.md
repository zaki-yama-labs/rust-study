第5章 ユーザ定義型
===============

### 5-1 スタック領域とヒープ領域

- スタック領域
  - 関数の引数やローカル変数などが格納されるメモリ領域
  - 複雑なしくみを使わずに管理できるため確保と解放が高速
  - 反面、サイズがあまり大きくない
- ヒープ領域
  - プログラム内で共有されるデータを格納するメモリ領域
  - 管理が複雑、スタックに比べ遅くなる
- Rust は
  - デフォルトで値をスタック老息に置く
  - 例外
    - Boxポインタ (`Box<T>`)
    - `Vec<T>`や`HashMap<K, V>` (要素数が可変のコレクション型)
    - `String`や`OSString` (文字の追加や削除が可能な文字列型)
    - Box以外は実行時に大きさが変更できるデータ構造


### 5-2 標準ライブラリの主な型

5-2-1 Box

- メモリ安全なポインタ
- 特徴
  - 対象のデータをヒープ領域に置く
  - ポインタでありながら、対象のデータを所有する

5-2-2 ベクタ

- プリミティブ型の配列との違い
  - 要素の追加や削除ができる
  - 配列はスタック領域に置かれるが、ベクタはヒープ領域にデータを置く

5-2-3 その他のコレクション型

- マップ HashMap
- セット HashSet
- キュー VecDeque
- リスト LinkedList (双方向)

5-2-4 String

- &strとStringは不変のスライスとベクタのそれに似ている
- 文字の変更・追加・削除が可能
- Stringから&strを作るとき:
  - Stringが所有する実データへの不変のスライス、つまりポインタの一種を作るだけ
  - -> 文字列の長さに関係なく、一定のごく短い時間で作成できるが、得られた文字列は不変
- &strからStringを作るとき:
  - &strが参照しているUTF-8バイト列が、Stringが所有する実データ用のスペースへコピーされる
  - -> 文字列の長さに比例する実行時間がかかるが、作った後は文字の追加・変更・削除が可能
- 関数の引数として文字列をとるとき、文字列が不変でかまわないなら作成コストの低い&strにするべき
  - 可変でないと困るなら&mut String
  - さらに所有権も必要ならString

5-2-5 範囲(std::ops::Range)

- `start..end`, `..=end` とかのこと


5-2-6 オプション(std::option::Option<T>)

- 値があるかどうか分からないことを表す型
- **nullを用いる言語だと、関数の戻り値からはnullを返す可能性があるのか判断できない**
- Some(T型の値) と None の2つのバリアントを持つ
- パターンマッチ(`match x { Some(value) => ... }`)や `if let Some(value) = x` で値を取り出せる
- `unwrap()`で取り出すとNoneのときpanicになるので、`unwrap_or_else(クロージャ)`など使うのがおすすめ
- アンラップせずに中の値を加工するためのメソッドとして、`map()`や`and_then()`のようなコンビネータ・メソッドがある
  - `map()`は加工した値をSome()で包み直す
  - `and_then()`は加工した値をそのまま返す
  - `Option<T>`を返す関数に対しての`map()`はSomeをネストしてしまうので、`and_then()`がベター
  - ref. https://doc.rust-jp.rs/rust-by-example-ja/error/option_unwrap/and_then.html
    - (`and_then()`は) "他の言語ではflatmapと呼ばれることもあります"
- ?演算子: Some(値)なら値を取り出し、NoneならNoneを返してこの関数からすぐにリターンする


5-2-7 リザルト(std::result::Result<T, E>)

- 処理の結果がエラーになる可能性を暗示する型
- `Ok(T型の結果を示す値)` と `Err(E型のエラーを示す型)` の2つのバリアントを持つ
- Rustでは例外を投げるかわりにリザルト型を使う
- Option同様、?演算子やコンビネータが使える
  - `map_err()`を使うとエラーを書き換えられる

> もしライブラリを開発して誰かに使ってもらうなら、これらのエラーが 起こったときにそのまま返さないほうがいいでしょう。独自のエラー型を定義して、それに変 換してから返すほうが利用者にとって使いやすくなることが多いです。

- 独自のエラー型を定義する際は、`std::convert::From`という型変換用のトレイトを実装するのがおすすめ

### 5-3 新しい型の定義と型エイリアス

5-3-1 型エイリアス

- TypeScriptのtype aliasとほぼ同じ
- 内部的に同じ型であれば、別の型エイリアスを渡してもエラーにならない

```rust
type Id = i64;
type Timestamp = i64;

fn new_user(id: Id, created: Timestamp) -> User {
}

let id = 100;
let now = 4567890123;
new_user(now, id); // OK
```

5-3-2 構造体(struct)

- 種類
  - 名前付きフィールド構造体: objectみたいなやつ
  - タプル構造体: `struct Vertex(i32, i32)`
  - ユニット構造体: 値を持たない
- 名前付きフィールド構造体
  - `Polygon { .. <既存のPolygonインスタンス> }` とすると既存の値をコピーして新しいインスタンスを生成できる
    - 関数型レコードアップデート構文(functional record update syntax)と呼ぶ
  - デフォルト値をもたせたい場合はDefaultトレイトを実装する
    - `#[derive(Default)]` をつけるか、`impl Default for Polygon` ブロックを自分で書く
- タプル構造体
  - newtype: 型エイリアスの代わりにフィールドが1つのタプル構造体を使うデザインパターン
  - 別の型を渡すとコンパイルエラー

5-3-3 列挙型(enum)

- 関数型言語で代数的データ型と呼ぶらしい
- 例: `Option<T>`: `Some(T)` と `None`
- バリアントには構造体と同じ記法でフィールドを持たせることができる
