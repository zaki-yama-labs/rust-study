第4章 プリミティブ型
=================

### 4-1 型の分類

- プリミティブ型かユーザ定義型か、という分類と、スカラ型か複合型か、という分類
- ユーザ定義型には、struct で定義した独自の型だけでなく、ベクタや文字列(String)も含まれる

### 4-2 スカラ型
- ユニット unit
  - 空のタプル `()`
- bool
- 固定精度の整数 i32, usize など
- 固定精度の浮動小数点数 f32, f64
- 文字 char
- 参照 reference
- 生ポインタ raw pointer
- 関数ポインタ fn pointer

4-2-3 固定精度整数

- 環境に依存しないビット幅指定の整数型: `i32, u8` など
- 環境に依存するアドレス幅の整数型: `isize, usize`
  - CPUのメモリアドレスのビット幅が32ビットならi32/u32, 64ビットならi64/u64と同じ
- オーバーフロー（桁あふれ）を
  - 検査付き演算(`checked_xxx`): 桁あふれが発生しなければ`Some(値)`を返し、発生したら`None`を返す
  - 飽和演算(`saturating_xxx`)：最大(小)値を上(下)回った場合は最大(小)値を返す
  - ラッピング演算(`wrapping_xxx`): 桁あふれを無視し、値の範囲を周回するようにふるまう
    - `600


4-2-5 文字

- 1文字を表す文字型はchar型という。シングルクォート
- 英数字であっても1文字に4バイト使う
  - `std::mem::size_of::<char>() // = 4`

4-2-6 参照

- **メモリ安全な** ポインタ
- 値に `&` をつけるとポインタ(データが格納されている場所)になる
- ポインタに `*` をつけると参照先(ポインタが指す値)にアクセスできる。参照外し(dereference)と呼ぶ
- プリミティブ型だと、`mut` をつけて関数に渡しても呼び出し元の値は変わらない

4-2-7 生ポインタ

- **メモリ安全ではない** ポインタ
- `*const T` または `*mut T`
- 参照外しおよび他のポインタ型への変換は`unsafe`ブロック内に書く必要がある


### 4-3 プリミティブな複合型

- タプル tuple
- 配列 array
- スライス slice
- 文字列スライス str

4-3-1 タプル

- 要素数はコンパイル時に決まる
- 各要素の型は異なってもOK

4-3-2 配列

- 要素はすべて同じ型
- 配列の要素はメモリ上の連続した領域に格納されるので、どの要素に対しても一定の時間でアクセスできる
- 配列の長さはコンパイル時に決まり、実行時には変えられない
- 要素へのアクセス方法
  1. インデックスを使う（実行時にパニックしない、安全な `get()` メソッドもある）
  2. イテレータを使う
- `len(), get(), iter()` などのメソッドは配列自体に備わっているわけではなく、スライスに備わっているもの。スライスのメソッドを呼び出したときに暗黙的に型強制するしくみになっている

配列はJSのそれとはだいぶ勝手が違って、型が揃ってないといけない、サイズがあらかじめ決まっていないといけないという制約がある。
後者については「メモリ上の連続した領域に格納される」ためにはそっかあという感想。


4-3-3 スライス

- 配列要素の範囲に効率よくアクセスするためのビュー
  - 配列要素の => 厳密には「連続したメモリ領域に同じ型の要素が並んでいるデータ構造ならなんでも」
- NOTE: `begin..end` としたとき、end は含まれない。含みたい場合は `begin..=end` とする
- スライスは範囲外のインデックスを指定してもコンパイルエラーにならない


4-3-4 文字列スライス

- str 型: Unicodeの文字で構成された文字列。
- 🤔"ほとんどの場合`str`にはスライスを通じてアクセスします。そのためstrは文字列スライス型と呼ばれ、`&str`か`&mut str`と表記します"
- 🤔"strリテラルはダブルクォートで作り、型は`&'static str`です"
- UTF-8のバイト数をカウントするメソッドは`len()`があるが、文字数をカウントするメソッドはない
