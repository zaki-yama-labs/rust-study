第8章 トレイトとポリモーフィズム
===========================

- トレイト: Rustでアドホックポリモーフィズムを実現する手段
  - アドホックポリモーフィズム:
    - 型によって振る舞いを返るポリモーフィズム
    - 代表的な例はオーバーロード
    - Rustのトレイトはオーバーロードよりも自由度が高く、他言語で型クラスと呼ばれることもある
- メソッド呼び出し構文、関連型、関連関数、関連定数

### 8-1 トレイトの基本

- トレイトは型に対して実装すべきメソッドを定義したもの
  - ここだけ聞くとインターフェースに感じる

8-1-2 トレイト境界

- ジェネリクスの型を「このトレイトを実装している型」というように境界を定める
- 3種類の方法
  1. ジェネリクスの型パラメータに直接 `<P: Coordinates>`
  2. 関数の型の後に `where P: Coordinates`
  3. 引数の型の位置に `point: impl Coordinates` (impl Trait構文)
- `where トレイト境界` の構文が一番柔軟

8-1-4 デフォルト実装

- トレイトのメソッドはデフォルト実装を持つこともできる

### 8-2 トレイトのジェネリクス

- トレイトはジェネリクスを持たせることもできる

```rust
trait Init<T> {
  fn init(t: T) -> Self;
}

impl<T> Init<T> for Box<T> {
  fn init(t: T) -> Self {
    Box::new(t)
  }
}
```

- 8-2-1 ジェネリクスを持つトレイトを実装するときに、型パラメータの部分に特定の型を指定することで複数種類の実装を書き分けることができる

### 8-3 静的ディスパッチと動的ディスパッチ

- ジェネリクスが内部的にどういうしくみになっているかの話
- Rustのジェネリクスは静的ディスパッチ
  - Good: 高速に普通の関数と変わらない速度で動作する
  - Bad: 生成されるバイナリが大きくなりがち（静的に解決できる情報が必要になったりコードをコピーしたりするので）
  - 動的ディスパッチのメリット・デメリットはこれの逆
- Rustで動的ディスパッチはトレイとオブジェクトで実現されており、`dyn Trait` という記法で表す
- トレイトオブジェクトを使うと、メソッドの実行はトレイトオブジェクトに格納されている関数ポインタ経由なので実行時に多少のコストがかかる

### 8-4 存在impl Trait

- 関数の戻り値型に書くimpl Trait
- 引数位置impl Traitは全称impl Traitと呼ばれる
- 戻り値位置impl Traitは存在型を表す存在impl Trait

```rust
fn to_n(n: i32) -> impl Iterator {
  0..n
}
```

↑「戻り値は `Iterator` を実装した何かしらの型である」と抽象化している
