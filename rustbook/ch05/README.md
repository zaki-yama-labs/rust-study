第5章 ユーザ定義型
===============

### 5-1 スタック領域とヒープ領域

- スタック領域
  - 関数の引数やローカル変数などが格納されるメモリ領域
  - 複雑なしくみを使わずに管理できるため確保と解放が高速
  - 反面、サイズがあまり大きくない
- ヒープ領域
  - プログラム内で共有されるデータを格納するメモリ領域
  - 管理が複雑、スタックに比べ遅くなる
- Rust は
  - デフォルトで値をスタック老息に置く
  - 例外
    - Boxポインタ (`Box<T>`)
    - `Vec<T>`や`HashMap<K, V>` (要素数が可変のコレクション型)
    - `String`や`OSString` (文字の追加や削除が可能な文字列型)
    - Box以外は実行時に大きさが変更できるデータ構造


### 5-2 標準ライブラリの主な型

5-2-1 Box

- メモリ安全なポインタ
- 特徴
  - 対象のデータをヒープ領域に置く
  - ポインタでありながら、対象のデータを所有する

5-2-2 ベクタ

- プリミティブ型の配列との違い
  - 要素の追加や削除ができる
  - 配列はスタック領域に置かれるが、ベクタはヒープ領域にデータを置く

5-2-3 その他のコレクション型

- マップ HashMap
- セット HashSet
- キュー VecDeque
- リスト LinkedList (双方向)

5-2-4 String

- &strとStringは不変のスライスとベクタのそれに似ている
- 文字の変更・追加・削除が可能
- Stringから&strを作るとき:
  - Stringが所有する実データへの不変のスライス、つまりポインタの一種を作るだけ
  - -> 文字列の長さに関係なく、一定のごく短い時間で作成できるが、得られた文字列は不変
- &strからStringを作るとき:
  - &strが参照しているUTF-8バイト列が、Stringが所有する実データ用のスペースへコピーされる
  - -> 文字列の長さに比例する実行時間がかかるが、作った後は文字の追加・変更・削除が可能
- 関数の引数として文字列をとるとき、文字列が不変でかまわないなら作成コストの低い&strにするべき
  - 可変でないと困るなら&mut String
  - さらに所有権も必要ならString

5-2-5 範囲(std::ops::Range)

- `start..end`, `..=end` とかのこと
